---
title: 'Лабораторная работа 5'
author: 'А.В. Родионов'
fontsize: '14pt'
geometry: 'margin=2cm'
paper: 'a4'
lang: 'russian'
template: 'default.html'
---

## Вспомогательные инструменты Git

### Ссылки на коммиты

Стандартным способом идентификации коммита в истории Git является его контрольная сумма (хэш) SHA-1.
Как правило, достаточно указать ее первые несколько знаков, при условии, что они не дублируются с
другими хэшами в базе и их количество не менее четырех. Просмотреть хэши коммитов в укороченном виде
можно командой `git log --abbrev-commit`.

Ветки и тэги являются указателями на коммит, поэтому все команды, которые принимают хэш, также могут
принимать имя ветки или тэга. Узнать хэш, на которую указывает ветка или тэг, можно командой `git
show <имя указателя>` или, в более компактном виде, `git rev-parse <имя указателя>`.

Все изменения веток и указателя `HEAD` сохраняются в журналах, которые также можно использовать для
навигации по коммитам. Журнал можно просмотреть командой `git relog`, записи в нем имеют вид `<имя
указателя>@{номер}` и позволяют сослаться не на номер коммита, а на этап в истории ветки. В качестве
номера можно использовать дату и время, в том числе относительные. Например, команда `git show
master@{yesterday}` покажет состояние ветки `master` на день раньше текущего времени. Журналы
изменений для веток носят локальный характер, они не переносятся между копиями репозитория.
По умолчанию записи в них хранятся не более 90 дней.

Указатель коммита может принимать модификатор `^`, который означает, что ссылка идет не на сам
коммит, а на его родителя. Например, `git show HEAD^` покажет не последний коммит ветки, а идущий
непосредственно перед ним. После `^` можно указать номер родительского коммита, если их было
несколько, т.е. коммит был результатом множественного слияния. Например `git show HEAD^2` сошлется
на второго родителя `HEAD`, если он у него есть. Несколько `^` подряд ссылаются на родителей
родителей и т.д. Например, чтобы показать третий коммит от текущего, можно воспользоваться командой
`git show HEAD^^^`. Чтобы не указывать длинные цепочки из символа `^`, можно воспользоваться
символом `~` и номером. Ссылка `HEAD~3` указывает на тот же коммит, что и `HEAD^^^`. 

Такие команды, как `git log` и `git diff` позволяют просматривать подмножество коммитов (диапазон),
которое задается ссылками на коммит, разделенными двумя точками (`..`). Например, команда `git
log origin/master..HEAD` означает, что Git должен выбрать все коммиты, доступные (являющиеся
предками) указателю `HEAD`, но недоступные из указателя `origin/master`, то есть показать, что
добавилось в текущей ветке по сравнению с `origin/master`. Запрос на диапазон коммитов можно делать
и без двух точек, просто перечисляя указатели в командной строке. Чтобы отсечь коммиты, недоступные
из какого-либо указателя, перед ним ставится символ `^` или ключ `--not`. Например, предыдущий
список коммитов можно вывести командой `git log ^origin/master HEAD` или `git log HEAD --not
origin/master`. 

Три точки между ссылками на коммиты означают, что нужно выбрать те из них, которые доступны из того
или иного указателя, но не из обоих сразу. Например, можно посмотреть, в каких изменениях разошлись
ветки `master` и `feature` командой `git log master...feature`. В этом случае, также может быть
полезен ключ `--left-right`, который добавляет к записям журнала подсказку, символ `<` или `>`. С ее
помощью можно увидеть, к какой из веток относится изменение.

### Команды `git reset` и `git checkout`

Команда `git reset` представляет собой средство для управления рабочим деревом проекта, индексом и
историей коммитов. Для понимания принципов ее работы, рассмотрим три хранилища данных, доступные в
репозитории Git:

* ветку, на которую указывает `HEAD`
* индекс изменений, которые войдут в следующий коммит
* рабочее дерево проекта

В зависимости от указанных в командной строке параметров, команда `git reset` работает в одном из
следующих режимов:

Режим `--soft` сбрасывает указатель ветки, на которую в данный момент указывает `HEAD`, в состояние,
соответствующее переданному в командной строке коммиту. При этом не затрагивается индекс и рабочее
дерево проекта, поэтому все изменения, сохраненные в индексе и еще не добавленные в него, могут
образовать один или более новых коммитов. На практике, сброс в режиме `--soft` применяют, когда
нужно заменить несколько последних коммитов в ветке на один. Для этого командой `git log` находят
хэш последнего коммита, который не будет затронут, а затем выполняют `git reset --soft <хэш
найденного коммита>`. Изменения, которые шли в истории коммитов за ним, будут отброшены, а текущее
состояние дерева проекта можно будет добавить в индекс и сформировать коммит. Фактически, этот
коммит будет представлять собой все изменения, которые накопились после выбранного, и заменит их
собой в истории коммитов. Команда `git commit --amend` производит аналогичные действия, но только с
последним коммитом в текущей ветке.

Режим `--mixed` сбрасывает не только указатель текущей ветки, но и состояние индекса в указанный в
командной строке коммит. Если коммит не задан, то будет выбран последний на вершине текущей ветки
(т.е. `HEAD`). Таким образом, команда `git reset --mixed` или, по умолчанию, просто `git reset`,
отменяет действие предыдущих команд `git add`, очищая индекс, но не затрагивая других хранилищ
проекта. В этом режиме, команду можно вызывать с именем файла или директории проекта. При этом
указатель ветки не будет сдвинут, но состояние определенных файлов в индексе будет приведено в
соответствие с заданным коммитом. Например, чтобы отменить добавление в индекс файла `file.txt`,
достаточно выполнить `git reset file.txt`.

Режим `--hard` сбрасывает проект в состояние, соответствующее выбранному коммиту, причем изменяются
все три хранилища: текущая ветка, индекс и рабочее дерево проекта. Все изменения, сделанные в файлах
проекта, будут утеряны при вызове этой команды. Его можно использовать, чтобы отказаться от
неудачного слияния или для отмены сделанных в рабочем дереве изменений.

Команды `git checkout <ветка или коммит>` и `git reset --hard <ветка или коммит>` действуют похожим
образом в том смысле, что рабочее дерево проекта приводится в состояние, соответствующее коммиту.
Однако, в отличие от `reset`, `git checkout` не передвигает указатель ветки, а только `HEAD`, что
позволяет не потерять коммиты, образующие ветку. Кроме того, если в дереве проекта имеются
недобавленные изменения, производится попытка их слияния с состоянием выбранного коммита.

Если передать команде `git checkout` файл или директорию, результат ее выполнения затронет как
индекс, так и рабочее дерево. Содержимое файлов будет сброшено в заданное состояние, изменения
утеряны как из рабочего дерева, так и из индекса, но указатель ветки и `HEAD` останутся прежними.

### Перебазирование

Слияние -- не единственный инструмент для управления историей коммитов в репозитории Git. В
некоторых случаях, вместо слияния веток с последующим удалением, желательно просто перенести коммиты
из одной ветки на вершину другой. Такая операция называется перебазированием, и производится, если
нужно сделать историю изменений проекта более линейной и читаемой. 

Пусть имеется ветка `develop` со текущим состоянием проекта, и ветка `feature` с экспериментальными
изменениями, которые были ответвлены от некоего коммита в прошлом. Стандартный
способ добавить эти изменения в `develop`, это слияние, с образованием нового коммита. Однако, можно
перенести коммиты из `feature` на вершину ветки `develop` так, как будто они были сделаны
непосредственно в ней. Это достигается командами:
    
    git checkout feature
    git rebase develop

При перебазировании, Git определяет общего предка двух веток, в данном случае, `feature` и
`develop`, находит разницу между вершиной `develop` и общим предком, а затем -- применяет эту
разницу и все коммиты от общего предка до вершины `feature` к вершине `develop`. В результате,
корень ветки `feature`, с учетом разницы, оказывается перенесен на вершину `develop`, а указатель
`develop` остается на месте. После перебазирования, можно слить `develop` и `feature` путем
перемотки вперед:

    git checkout develop
    git merge feature

После выполнения всех команд, состояние рабочего дерева проекта будет в точности таким же, как если
бы было выполнено обычное слияние, но коммиты ветки `feature` будут образовывать не боковую ветку, а
отрезок на линейной последовательности изменений в ветке `develop`. Если впоследствии удалить
`feature`, уже будет невозможно определить, были ли изменения внесены отдельной веткой или
добавлялись непосредственно в `develop`.

Перебазирование напрямую вмешивается в базу коммитов репозитория. В целом, эта операция считается
безопасной, пока не затронуты изменения, уже отправленные во внешние репозитории. Если же это
произошло, Git не позволит отправить новую порцию изменений командой `git push`, пока в командной
строке не будет указан флаг `--force`. С другой стороны, измененные в основном репозитории ветки
могут вызвать конфликты с локальными копиями других разработчиков, которые сохранили старую
последовательность коммитов. Для разрешения этих конфликтов, прием изменений из перебазированного
репозитория необходимо производить командой `git pull --rebase`.
